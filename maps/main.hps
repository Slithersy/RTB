#include "interfaces/Map_Interface.hps"
#include "base/Inputhandler_Types.hps"

#include "helpers/helper_map.hps"
#include "helpers/helper_props.hps"
#include "helpers/helper_effects.hps"
#include "helpers/helper_audio.hps"
#include "helpers/helper_imgui.hps"
#include "helpers/helper_sequences.hps"
#include "helpers/helper_game.hps"
#include "helpers/helper_modules.hps"
#include "helpers/helper_ai.hps"
#include "helpers/helper_player.hps"
#include "helpers/helper_procedural.hps"
#include "helpers/helper_rotation.hps"

//--------------------------------------------------
 
/*Place any global values here. These must be const variables as they will not be saved*/
/*This is also the place for enums and classes, but these should be avoided whenever possible*/
 
//--------------------------------------------------
 
class cScrMap : iScrMap
{
	//--------------------------------------------
 
	//////////////////////////////////////////////////////////////////////////////////////////
	// ==============
	// MAIN CALLBACKS
	// ==============
	//{///////////////////////////////////////////////////////////////////////////////////////
 
	//-------------------------------------------------------
 
	////////////////////////////
	// Set up map environment
	void Setup()
	{
		// Put display name entry in english.lang / Levels
		GetBase().SetDisplayNameEntry("main-bunker-level");
        
        // Basic can can't do
        Player_SetAllowCheckBaby(false);
		
		// Set up color grading etc.
	}
	
	//-------------------------------------------------------
		
	void PreloadData()
	{
		/////////////////
		// Preload gui
		//ImGui_PreloadImage("some_image");

		///////////////
		// Preload particles
		//ParticleSystem_Preload("some_particle.ps");

		//////////////
		// Preload screen effects
		//Material_Preload("some_material.mat");
	}
	
	//-------------------------------------------------------

	////////////////////////////
	// Run first time starting map
    
    // Enterance
    tString msFirstRemovedWall = "";
    
    array<int> mvStack;
	void OnStart()
	{
        // Give player stuff
        if (ItemType_GetCountInInventory("Lantern") < 1)
        {
            Item_AddToInventory("Lantern");
            Lantern_SetAmount(10);
            Item_Equip("Lantern");
        }
        
        Item_AddToInventory("ModernOil");
        Item_AddToInventory("ModernOil");
            
		/////////////////////////
		// MAZE GENERATION
        
        //Reset everything to default
        Chunk_ResetArray();
        
        // Pick starting chunk
        lChunkStart = cMath_RandRectl(1, 64);
        Chunk_SetStartingCell(lChunkStart)
        int lNeighbourCell = 1;
        cLux_AddDebugMessage("Start chunk - "+lChunkStart);
        Player_PlaceAtEntity("start_chunk_"+lChunkStart, true);
        // Mark as visited
        Chunk_SetBeenVisited(lChunkStart, true);
        
        // Pick a neighbouring cell that haven't been visited, currently all and set the walls between us and it inactive
        // Also set it visited
        lNeighbourCell = Chunk_PickNeighbouringCell(lChunkStart);
        if (lNeighbourCell!=-1)
            msFirstRemovedWall = Chunk_SetWallBetweenCells(lChunkStart, lNeighbourCell, false);
            mvStack.insertLast(lNeighbourCell);
            Chunk_SetBeenVisited(lNeighbourCell, true);
            
        // For realism, make a chunk where the door is supposed to be unuseable
        if ((lChunkStart+1) == lNeighbourCell) { //Right
            tString sWall = Chunk_SetWallBetweenCells(lChunkStart,lChunkStart-1, true);
            if (sWall != "") {
                int lChunk = cString_ToInt(cString_Split(sWall, "_")[2], lChunkStart);
                Chunk_SetBeenVisited(lChunk, true);
                Chunk_SetContainsBuilding(lChunk, true);
            }
        } else if ((lChunkStart-1) == lNeighbourCell) { //Left
            tString sWall  = Chunk_SetWallBetweenCells(lChunkStart, lChunkStart+1, true);
            if (sWall != "") {
                array<tString> vWallSplit = cString_Split(sWall, "_");
                if (vWallSplit.size()>3) {
                    int lChunk = cString_ToInt(vWallSplit[3], lChunkStart);
                    Chunk_SetBeenVisited(lChunk, true);
                    Chunk_SetContainsBuilding(lChunk, true);
                }
            }
        } else if ((lChunkStart+8) == lNeighbourCell) { //Up
            tString sWall  = Chunk_SetWallBetweenCells(lChunkStart, lChunkStart-8, true);
            if (sWall != "") {
                int lChunk = cString_ToInt(cString_Split(sWall, "_")[2], lChunkStart);
                Chunk_SetBeenVisited(lChunk, true);
                Chunk_SetContainsBuilding(lChunk, true);
            }
        } else if ((lChunkStart-8) == lNeighbourCell) { //Down
            tString sWall  = Chunk_SetWallBetweenCells(lChunkStart, lChunkStart+8, true);
            if (sWall != "") {
                array<tString> vWallSplit = cString_Split(sWall, "_");
                if (vWallSplit.size()>3) {
                    int lChunk = cString_ToInt(vWallSplit[3], lChunkStart);
                    Chunk_SetBeenVisited(lChunk, true);
                    Chunk_SetContainsBuilding(lChunk, true);
                }
            }
        }
            
        int lSafetyCheck = 0;
        bool bNonVisistedExist = true;
        while (bNonVisistedExist) {
            // If there are unvisited chunks keep looping, otherwise stop
            bool bShouldStopLoop = true;
            for (int i=1;i<65;i++) {
                if (!Chunk_HasBeenVisited(i)) {
                    bShouldStopLoop = false;
                    break;
                }
            }
            if (bShouldStopLoop)
                bNonVisistedExist = false;
            
            // from 0.0f - 0.99f how likely is the for loop to skip for more randomization
            float fSkipChance = 0.65f;
            // from 0.1f - 0.99f how random do you want the array to be
            float fRandomizeChance = 0.99f;
            array<int> vRandomizedStack = RandomizeArray(mvStack, fRandomizeChance);
            int length = vRandomizedStack.length();
            
            // Here the magic happens! (I'm so happy this works) :>
            for (int i=0;i<length;i++) {
                if (fSkipChance < cMath_RandRectf(0.0f,1.0f)) {
                    cLux_AddDebugMessage("Picking neighbour around: "+vRandomizedStack[i]);
                    int lNewNeighbourCell = Chunk_PickNeighbouringCell(vRandomizedStack[i]);
                    cLux_AddDebugMessage("Picked: "+lNewNeighbourCell);
                    if (lNewNeighbourCell!=-1) {
                        Chunk_SetWallBetweenCells(vRandomizedStack[i], lNewNeighbourCell, false);
                        mvStack.insertLast(lNewNeighbourCell);
                        Chunk_SetBeenVisited(lNewNeighbourCell, true);
                    }
                }
            }
            
            if (lSafetyCheck>70) {
                bNonVisistedExist = false;
                Error("While infinite loop in main!!!");
            }
            
            lSafetyCheck++;
        }
        
        ///////////////////
        // ENTERANCE
        
        // First remove roof
        Entity_SetActive("roof_chunk_"+lChunkStart, false);  
        Chunk_SetContainsBuilding(lChunkStart, true);
        
        // Place Enterance
        iLuxEntity@ pPlayerStart = Map_GetEntity("start_chunk_"+lChunkStart, eLuxEntityType_Area);
        if (pPlayerStart is null)
        {
            Error("Could not find the target entity "+"start_chunk_"+lChunkStart);
            return;
        }
        
        iLuxEntity@ pEnterance = Map_GetEntity("Enterance", eLuxEntityType_Area);
        if (pEnterance is null)
        {
            Error("Could not find the target entity Enterance");
            return;
        }
        pEnterance.SetPosition(pPlayerStart.GetPosition());
        
        // Set rotation
        Entity_FaceToEntity("Enterance", msFirstRemovedWall, false);
        
        
        ///////////////////
        // EXIT/BUILDING GENERATION
        Building_PlaceInChunk(const tString &in asAreaName, int alChunkNum=-1, bool abChangeMaze=true);
	}

	//-------------------------------------------------------

	////////////////////////////
	// Run when entering map
	void OnEnter()
	{
		/////////////////////////
		// Debug
		if(cLux_ScriptDebugOn())
		{
		}
        
        // Basic player stuff
        PlayerBody_SetActive(true);
        FearHandler_SetActive(true);
        FearHandler_SetPaused(false);
        FearHandler_SetAllowLanternReminderHint(true);
        FearHandler_SetDarknessFactorActive(true);
		FearHandler_SetUpdateInterval(0.1f);
        FearHandler_SetMaxLevel(2.0f);
        Player_SetMapDeepShadow(0.9f);
		FearHandler_SetPermaFailEnabled(true);
        Heat_SetActive(false);
		Player_SetNightVisionBrightness(2.3f);
		Player_SetNightVisionRadius(5.5f);
        
		Game_AutoSave();
	}

	//-------------------------------------------------------

	////////////////////////////
	// Run when leaving map
	void OnLeave()
	{
	}

	//-------------------------------------------------------

	////////////////////////////
	// The player has died.
	void OnPlayerKilled(int alRecentDeaths, const tString&in asSource)
	{
	}
	
	//-------------------------------------------------------
	
	////////////////////////////////////
	// Called when player HP reaches 0
	bool OnDeath(const tString &in asSource)
	{
		cLux_AddTodoMessage("DEAD : SOURCE = " + asSource);
		
		if (asSource == "SomeReason")
		{
			Effect_Fade_Out(1.0f);
			return true; // return true to completely override base behaviour
		}
		
		// return false for default behaviour
		return false;
	}
	
	//-------------------------------------------------------
	
	////////////////////////////////////
	// Called when player should respawn (after death)
	bool OnRespawn(const tString &in asSource)
	{		
		// return false for default behaviour (fadeout and death area)
		return false;
	}

	//-------------------------------------------------------

	////////////////////////////
	// To get when player makes input (mostly used for debug)
	void OnAction(int alAction, bool abPressed) 
	{
		if(abPressed==false) return;
		
		if(alAction == eAction_Test1)
		{
		}
	}

	//-------------------------------------------------------

	////////////////////////////
	// This only used for pure debug purposes when info needs to printed.
	float DrawDebugOutput(cGuiSet @apSet,iFontData @apFont,float afY)
	{
		//afY = cLux_DrawDebugText("My Debug value:"+..., afY);
		return afY;
	}
 
	//-------------------------------------------------------
 
	//} END MAIN CALLBACKS
 
 
	//////////////////////////////////////////////////////////////////////////////////////////
	// ==============
	// MAIN FUNCTIONS
	// ==============
	//{///////////////////////////////////////////////////////////////////////////////////////
 
	//-------------------------------------------------------
 
    // When you click on the exit ladder
    void OnExitLadder(const tString &in asEntity)
    {
        cLux_AddDebugMessage("Clicked on Exit Ladder");
    }
 
	//-------------------------------------------------------
 
	//} END MAIN FUNCTIONS
 
}