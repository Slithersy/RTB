#include "interfaces/Map_Interface.hps"
#include "base/Inputhandler_Types.hps"

#include "helpers/helper_map.hps"
#include "helpers/helper_props.hps"
#include "helpers/helper_effects.hps"
#include "helpers/helper_audio.hps"
#include "helpers/helper_imgui.hps"
#include "helpers/helper_sequences.hps"
#include "helpers/helper_game.hps"
#include "helpers/helper_modules.hps"
#include "helpers/helper_ai.hps"
#include "helpers/helper_player.hps"
#include "helpers/helper_procedural.hps"
#include "custom/helpers/helper_agent.hps"

//--------------------------------------------------
 
/*Place any global values here. These must be const variables as they will not be saved*/
/*This is also the place for enums and classes, but these should be avoided whenever possible*/
 
//--------------------------------------------------
 
class cScrMap : iScrMap
{
	//--------------------------------------------
 
	//////////////////////////////////////////////////////////////////////////////////////////
	// ==============
	// MAIN CALLBACKS
	// ==============
	//{///////////////////////////////////////////////////////////////////////////////////////
 
	//-------------------------------------------------------
 
	////////////////////////////
	// Set up map environment
	void Setup()
	{
		// Put display name entry in english.lang / Levels
		GetBase().SetDisplayNameEntry("main-bunker-level");
        
        // Basic can can't do
        Player_SetAllowCheckBaby(false);
		
		// Set up color grading etc.
	}
	
	//-------------------------------------------------------
		
	void PreloadData()
	{
		/////////////////
		// Preload gui
		//ImGui_PreloadImage("some_image");

		///////////////
		// Preload particles
		//ParticleSystem_Preload("some_particle.ps");

		//////////////
		// Preload screen effects
		//Material_Preload("some_material.mat");
	}
	
	//-------------------------------------------------------

	////////////////////////////
	// Run first time starting map
    
    // Enterance
    tString msFirstRemovedWall = "";
    
    array<int> mvStack;
	void OnStart()
	{
        // Make all fog invisible
        for (int i=1;i<=64;i++) {
            FogArea_SetVisible("FogArea_"+i, false);
        }
        
        // Give player stuff
        if (ItemType_GetCountInInventory("Lantern") < 1)
        {
            Item_AddToInventory("Lantern");
            Lantern_SetAmount(10);
            Item_Equip("Lantern");
        }
        
        Item_AddToInventory("ModernOil");
        Item_AddToInventory("ModernOil");
        Item_AddToInventory("ModernOil");
        Item_AddToInventory("ModernOil");
        // Remove bracelet and add watch instead
        Item_AddToInventory("Watch");
        Item_RemoveFromInventory(ItemType_GetFirstInInventory("CurseMedallion"));
            
		/////////////////////////
		// MAZE GENERATION
        
        //Reset everything to default
        Chunk_ResetArray();
        Building_ResetArray();
        
        // Pick starting chunk
        int lChunkStart = cMath_RandRectl(1, 64);
        Chunk_SetStartingCell(lChunkStart);
        int lNeighbourCell = 1;
        cLux_AddDebugMessage("Start chunk - "+lChunkStart);
        Player_PlaceAtEntity("start_chunk_"+lChunkStart, true);
        // Mark as visited
        Chunk_SetBeenVisited(lChunkStart, true);
        
        // Pick a neighbouring cell that haven't been visited, currently all and set the walls between us and it inactive
        // Also set it visited
        lNeighbourCell = Chunk_PickNeighbouringCell(lChunkStart);
        if (lNeighbourCell!=-1)
            msFirstRemovedWall = Chunk_SetWallBetweenCells(lChunkStart, lNeighbourCell, false);
            mvStack.insertLast(lNeighbourCell);
            Chunk_SetBeenVisited(lNeighbourCell, true);
            
        ///////////////////
        // ENTERANCE
        // First remove roof
        Entity_SetActive("roof_chunk_"+lChunkStart, false);  
        Chunk_SetContainsBuilding(lChunkStart, true);
        
        // Place Enterance
        iLuxEntity@ pPlayerStart = Map_GetEntity("start_chunk_"+lChunkStart, eLuxEntityType_Area);
        if (pPlayerStart is null)
        {
            Error("Could not find the target entity "+"start_chunk_"+lChunkStart);
            return;
        }
        
        iLuxEntity@ pEnterance = Map_GetEntity("Enterance", eLuxEntityType_Area);
        if (pEnterance is null)
        {
            Error("Could not find the target entity Enterance");
            return;
        }
        pEnterance.SetPosition(pPlayerStart.GetPosition());
        
        // Set rotation
        Entity_FaceToEntity("Enterance", msFirstRemovedWall, false);
            
        // For realism, make a chunk where the door is supposed to be unuseable
        int lBehindChunk = Building_GetCellBehind("Enterance", lChunkStart);
        if (lBehindChunk != -1) {
            Chunk_SetBeenVisited(lBehindChunk, true);
            Chunk_SetContainsBuilding(lBehindChunk, true);
        }
        
        ///////////////////
        // MONSTER STUFF
        array<int> AvailableMonsterChunks;
        for (int i=0;i<65;i++) {
            if ((i!=lNeighbourCell) && (i!=lChunkStart))
                AvailableMonsterChunks.insertLast(i);
        }
        if (AvailableMonsterChunks.length()>3) {
            for (int i=1;i<4;i++) {
                int lRanIndex = cMath_RandRectl(0,AvailableMonsterChunks.length()-1);
                int lRanMonsterChunk = AvailableMonsterChunks[lRanIndex];
                AvailableMonsterChunks.removeAt(lRanIndex);
                Chunk_SetContainsBuilding(lRanMonsterChunk, true);
                
                // Place Monster chunk
                iLuxEntity@ pPlayerMonsterStart = Map_GetEntity("start_chunk_"+lRanMonsterChunk, eLuxEntityType_Area);
                if (pPlayerMonsterStart is null)
                {
                    Error("Could not find the target entity "+"start_chunk_"+lRanMonsterChunk);
                    return;
                }
                
                iLuxEntity@ pMonsterChunk = Map_GetEntity("MonsterArea_"+i, eLuxEntityType_Area);
                if (pMonsterChunk is null)
                {
                    Error("Could not find the target entity MonsterArea_"+i);
                    return;
                }
                pMonsterChunk.SetPosition(pPlayerMonsterStart.GetPosition());
                
                // Make it face a random direction
                int lRanNum = cMath_RandRectl(1,4);
                tString sWall = "";
                // Left
                if (lRanNum==1) {
                    sWall = Chunk_SetWallBetweenCells(lRanMonsterChunk, lRanMonsterChunk-1, false, false);
                // Right
                } else if (lRanNum==2) {
                    sWall = Chunk_SetWallBetweenCells(lRanMonsterChunk, lRanMonsterChunk+1, false, false);
                // Up
                } else if (lRanNum==3) {
                    sWall = Chunk_SetWallBetweenCells(lRanMonsterChunk, lRanMonsterChunk+8, false, false);
                // Down
                } else {
                    sWall = Chunk_SetWallBetweenCells(lRanMonsterChunk, lRanMonsterChunk+8, false, false);
                }
                Entity_FaceToEntity("MonsterArea_"+i, sWall, false);
                    
                // For realism, make a chunk where the wall is supposed to be unuseable
                int lBehindMonsterChunk = Building_GetCellBehind("MonsterArea_"+i, lRanMonsterChunk, true);
                if (lBehindMonsterChunk != -1) {
                    Chunk_SetBeenVisited(lBehindMonsterChunk, true);
                    Chunk_SetContainsBuilding(lBehindMonsterChunk, true);
                    Chunk_SetWallBetweenCells(lRanMonsterChunk, lBehindMonsterChunk, false, true);
                    
                    if ((lBehindMonsterChunk<=64) && (lBehindMonsterChunk>=1))
                        FogArea_SetVisible("FogArea_"+lBehindMonsterChunk, true);
                }
            }
        }
        
        ///////////////////
        // BACK TO GENERATION
            
        int lSafetyCheck = 0;
        bool bNonVisistedExist = true;
        while (bNonVisistedExist) {
            // If there are unvisited chunks keep looping, otherwise stop
            bool bShouldStopLoop = true;
            for (int i=1;i<65;i++) {
                if (!Chunk_HasBeenVisited(i)) {
                    bShouldStopLoop = false;
                    break;
                }
            }
            if (bShouldStopLoop)
                bNonVisistedExist = false;
            
            // from 0.0f - 0.99f how likely is the for loop to skip for more randomization
            float fSkipChance = 0.65f;
            // from 0.1f - 0.99f how random do you want the array to be
            float fRandomizeChance = 0.99f;
            array<int> vRandomizedStack = RandomizeArray(mvStack, fRandomizeChance);
            int length = vRandomizedStack.length();
            
            // Here the magic happens! (I'm so happy this works) :>
            for (int i=0;i<length;i++) {
                if (fSkipChance < cMath_RandRectf(0.0f,1.0f)) {
                    cLux_AddDebugMessage("Picking neighbour around: "+vRandomizedStack[i]);
                    int lNewNeighbourCell = Chunk_PickNeighbouringCell(vRandomizedStack[i]);
                    cLux_AddDebugMessage("Picked: "+lNewNeighbourCell);
                    if (lNewNeighbourCell!=-1) {
                        Chunk_SetWallBetweenCells(vRandomizedStack[i], lNewNeighbourCell, false);
                        mvStack.insertLast(lNewNeighbourCell);
                        Chunk_SetBeenVisited(lNewNeighbourCell, true);
                    }
                }
            }
            
            if (lSafetyCheck>70) {
                bNonVisistedExist = false;
                Error("While infinite loop in main!!!");
            }
            
            lSafetyCheck++;
        }
        
        
        ///////////////////
        // EXIT/BUILDING GENERATION
        Building_PlaceInChunk("Exit", -1, 1.0f);
        Building_PlaceInChunk("GeneratorRoom", -1);
        Building_PlaceInChunk("KeyRoom", -1, 1.0f, 0.0f);
        Building_PlaceInChunk("MedRoom", -1);
        Building_PlaceInChunk("ArmoryRoom", -1);
        
        // Generate Assets
        for (int i=1;i<=4;i++) {
            Building_PlaceInChunk("LampArea_"+i, -1, 0.2f, 0.8f);
        }
	}

	//-------------------------------------------------------

	////////////////////////////
	// Run when entering map
	void OnEnter()
	{
		/////////////////////////
		// Debug
		if(cLux_ScriptDebugOn())
		{
		}
        
        // Basic player stuff
        PlayerBody_SetActive(true);
        FearHandler_SetActive(true);
        FearHandler_SetPaused(false);
        FearHandler_SetAllowLanternReminderHint(true);
        FearHandler_SetDarknessFactorActive(true);
		FearHandler_SetUpdateInterval(0.1f);
        FearHandler_SetMaxLevel(2.0f);
        Player_SetMapDeepShadow(0.9f);
		FearHandler_SetPermaFailEnabled(true);
        Heat_SetActive(false);
		Player_SetNightVisionBrightness(2.3f);
		Player_SetNightVisionRadius(5.5f);
        
		Game_AutoSave();
	}
    
    float lMonsterTime = 0.0f;
    float fRanTimeBetween = 30.0f;
    float fMonsterGetOutChance = 0.1f;
    bool bMonsterIsOut = false;
    void Update(float afDeltaTime)
    {
        Watch_AddRunTime(afDeltaTime);

        // For monster, just need the global time
        float GlobalTime = Watch_GetRunTime();
        
        if ((GlobalTime - lMonsterTime) > fRanTimeBetween) {
            float fRanNum = cMath_RandRectf(0.01f,1.0f); 
            if (bMonsterIsOut) {
                if (fRanNum<fMonsterGetOutChance) {
                    // Make monster retreat
                    Ghoul_CommandGoToSpecificHole_Execute("ghoul_1", "MonsterArea_"+lMonsterIndex, false, false, true);
                } else
                    fMonsterGetOutChance = fMonsterGetOutChance*1.2;
                lMonsterTime = GlobalTime;
                return;
            }
            
            Monster_PickSpot();
            
            fRanTimeBetween = cMath_RandRectf(30.0f, 60.0f);
            lMonsterTime = GlobalTime;
            
            if (fRanNum<fMonsterGetOutChance) {
                iLuxEntity@ pMonster = Map_GetEntity("ghoul_1", eLuxEntityType_Agent);
                iLuxEntity@ pArea = Map_GetEntity("MonsterArea_"+lMonsterIndex, eLuxEntityType_Area);
                if ((pMonster is null) || (pArea is null)) {
                    Error("Could not find the target entity ghoul_1 or MonsterArea_"+lMonsterIndex);
                } else {
                    fMonsterGetOutChance = 0.1f;
                    pMonster.SetPosition(pArea.GetPosition());
                    Entity_SetActive("ghoul_1", true);
                    Ghoul_CommandEmergeFromHole_Execute("ghoul_1", "MonsterArea_"+lMonsterIndex, true);
                    Monster_PickSpot(false);
                    Ghoul_CommandPatrol_Execute("ghoul_1", false, 20, true);
                    bMonsterIsOut = true;
                }
            } else {
                // Each time the monster doesn't come out, the chance for it to come out the next time increases
                fMonsterGetOutChance = fMonsterGetOutChance*1.2;
            }
        }
    }
    
    //-------------------------------------------------------
    //MONSTER STUFF
    //-------------------------------------------------------
    
    int lMonsterIndex = -1;
    void Monster_PickSpot(bool abNoSpot=false)
    {
        lInSoundArea = -1;
        Sound_Stop("MonsterBreathe", 3.0f);
        FearHandler_StopStruggleSoundLoop(6.0f);
        
        array<int> AvailableSpawnAreas;
        for (int i=1; i<=3; i++) {
            if ((lInSoundArea != i) && (lMonsterIndex!=i)) {
                AvailableSpawnAreas.insertLast(i);
            }
        }
        if (abNoSpot) {
            lMonsterIndex = -1;
            //cScript_SetGlobalVarInt("Monster_Index", lMonsterIndex);
        }
        else if (AvailableSpawnAreas.size()>0) {
            lMonsterIndex = AvailableSpawnAreas[cMath_RandRectl(0, AvailableSpawnAreas.length()-1)];
            //cScript_SetGlobalVarInt("Monster_Index", lMonsterIndex);
        }
        
        cLux_AddDebugMessage("Picked area: "+lMonsterIndex);
    }
    
    // When entering monster sound area
    int lInSoundArea = -1;
    bool Monster_SoundArea(const tString &in asParent, const tString &in asChild, int alState)
    {
        int lAreaIndex = cString_ToInt(cString_Split(asParent, "_")[2], -2);
        cLux_AddDebugMessage("Parent is: "+asParent);
        if (alState == 1) {
            lInSoundArea = lAreaIndex;
            if (lMonsterIndex == lAreaIndex) {
                Sound_CreateAtEntity("MonsterBreathe", "custom/monster/praying", "MonsterWall_"+lAreaIndex, 15.0f, false, 1.0f);
                FearHandler_PlayStruggleSoundLoop(15.0f, 0.3f, false);
                FearHandler_SetForcedAddFearRate(eFearForcedRateType_Struggle, 2.0f, -1.0f, true, 5.0f, -1.0f, 2.0f);
                FearHandler_FadeRateMulTo(eFearRateMulType_Script, 1.4f, 10.0f);
            }
            cLux_AddDebugMessage("Entered area "+lAreaIndex);
        } else {
            lInSoundArea = -1;
            if (lMonsterIndex == lAreaIndex) {
                Sound_Stop("MonsterBreathe", 3.0f);
                FearHandler_StopStruggleSoundLoop(6.0f);
                FearHandler_FadeRateMulTo(eFearRateMulType_Script, 1.0f, 10.0f);
            }
            cLux_AddDebugMessage("Left area "+lAreaIndex);
        }
        return true;
    }
    
    bool Monster_KillArea(const tString &in asParent, const tString &in asChild, int alState)
    {
        cLux_AddDebugMessage("Entered kill area");
        
        int lAreaIndex = cString_ToInt(cString_Split(asParent, "_")[2], -2);
        if ((alState == 1) && (lMonsterIndex == lAreaIndex)) {
            //FearHandler_TriggerPermaFail(true, "assource", false);
            FearHandler_TriggerPermaFail_Fall();
            Monster_PickSpot(false);
            cLux_AddDebugMessage("Perma fail");
        }
        return true;
    }
    
    bool Monster_EnterArea(const tString &in asParent, const tString &in asChild, int alState)
    {
        if (alState==1)
            cLux_AddDebugMessage("Monster retreated");
        return true;
    }
    
    //-------------------------------------------------------
    //GENERATOR SEQUENCE
    //-------------------------------------------------------
    
    float mfChanceOfFailure = 0.2f;
    bool mbGenLeverOn = false;
    void GeneratorLevelInteract(const tString &in asEntity)
    {
        if ((Lever_GetState(asEntity) == 1) && (!mbGenLeverOn)) {
            Seq_GeneratorStart("");
            mbGenLeverOn = true;
            Entity_SetInteractionDisabled("Generator_Lever", true);
        }
    }
    
    bool bPlayedVoice = false;
    void PlayTryAgainHint()
    {
        if (!bPlayedVoice) {
            Voice_Play("Dialogue_TryGen");
            bPlayedVoice = true;
        }
    }
    
	cSequenceStatesData mSequenceGeneratorStart;
	void Seq_GeneratorStart(const tString &in asTimer)
	{
		Sequence_Begin("Seq_GeneratorStart", mSequenceGeneratorStart);
		if (Sequence_DoStepAndWait(1.0f))
		{
            ParticleSystem_CreateAtEntity("gen_spark1", "elec_spark_medium_oneshot.ps", "GeneratorRoom_ParticleSpawner_1", true);
            Sound_CreateAtEntity("gen_spark1_noise", "custom/generator/spark", "GeneratorRoom_ParticleSpawner_1", 0.0f, false, 1.0f);
            
            int lRanInt = cMath_RandRectl(0, 100);
            float fRanFloat = lRanInt/100.0f;
            cLux_AddDebugMessage(""+fRanFloat+" is lower than "+mfChanceOfFailure);
            if (fRanFloat < mfChanceOfFailure) {
                Lever_SetStuckState("Generator_Lever", -1, true);
                Map_AddTimer("Timer_AllowLeverUse", 1.0f, "Timer_AllowLeverUse");
                PlayTryAgainHint();
                Sequence_Stop();
            }
		}
		else if (Sequence_DoStepAndWait(0.7f))
		{
            ParticleSystem_CreateAtEntity("gen_spark2", "elec_spark_medium_oneshot.ps", "GeneratorRoom_ParticleSpawner_2", true);
            Sound_CreateAtEntity("gen_spark2_noise", "custom/generator/spark", "GeneratorRoom_ParticleSpawner_2", 0.0f, false, 1.0f);
            
            int lRanInt = cMath_RandRectl(0, 100);
            float fRanFloat = lRanInt/100.0f;
            if (fRanFloat < mfChanceOfFailure) {
                Lever_SetStuckState("Generator_Lever", -1, true);
                Map_AddTimer("Timer_AllowLeverUse", 1.0f, "Timer_AllowLeverUse");
                PlayTryAgainHint();
                Sequence_Stop();
            }
        }
		else if (Sequence_DoStepAndWait(0.7f))
		{
            ParticleSystem_CreateAtEntity("gen_spark3", "elec_spark_medium_oneshot.ps", "GeneratorRoom_ParticleSpawner_3", true);
            Sound_CreateAtEntity("gen_spark3_noise", "custom/generator/spark", "GeneratorRoom_ParticleSpawner_3", 0.0f, false, 1.0f);
        }
		else if (Sequence_DoStepAndWait(2.f))
		{
            Lamp_SetLit("generator_light", true, true);
            Lamp_SetLit("GeneralLamp_1", true, true);
            Sound_CreateAtEntity("Sound_GeneralLamp_1", "custom/generator/light_buzz", "GeneralLamp_1", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("GeneratorStart", "custom/generator/generator_on", "GeneratorRoom_SoundSpawner", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("gen_LightOn1", "custom/generator/light_on", "GeneratorRoom_SoundSpawner_2", 0.0f, false, 1.0f);
        }
		else if (Sequence_DoStepAndWait(3.f))
		{
            Lamp_SetLit("GeneralLamp_*", true, true);
            Sound_CreateAtEntity("Sound_GeneralLamp_2", "custom/generator/light_buzz", "GeneralLamp_2", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("Sound_GeneralLamp_3", "custom/generator/light_buzz", "GeneralLamp_3", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("Sound_GeneralLamp_4", "custom/generator/light_buzz", "GeneralLamp_4", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("Sound_GeneralLamp_5", "custom/generator/light_buzz", "GeneralLamp_5", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("Sound_GeneralLamp_6", "custom/generator/light_buzz", "GeneralLamp_6", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("Sound_GeneralLamp_7", "custom/generator/light_buzz", "GeneralLamp_7", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("Sound_GeneralLamp_8", "custom/generator/light_buzz", "GeneralLamp_8", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("Sound_GeneralLamp_9", "custom/generator/light_buzz", "GeneralLamp_9", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("gen_LightOn2", "custom/generator/light_switch", "GeneratorRoom_SoundSpawner_2", 0.0f, false, 1.0f);
            Map_AddTimer("Timer_GeneratorStop", 30.0f, "Timer_GeneratorStop");
            
            if (!mbKeyRoomInteracted)
                Prop_MoveLinearTo("KeyDoor_Blocker_1","KeyDoor_Blocker_2",70,70,0.2f,true);
        }
		else if (Sequence_DoStepAndWait(2.f))
		{
            if (!mbKeyRoomInteracted) {
                SwingDoor_SetLocked("KeyRoom_Wall1_1", false, true);
                Entity_SetActive("KeyBlock", false);
            }
        }
		Sequence_End();
	}
    
    void Timer_GeneratorStop(const tString &in asTimer)
    {
        Sound_Stop("GeneratorStart", 0.5f);
        Sound_Stop("Sound_GeneralLamp_*", 0.5f);
        Sound_CreateAtEntity("Sound_GeneralLampOff_1", "custom/generator/light_off", "GeneralLamp_1", 0.4f, false, 1.0f);
        Sound_CreateAtEntity("Sound_GeneralLampOff_2", "custom/generator/light_off", "GeneralLamp_2", 0.4f, false, 1.0f);
        Sound_CreateAtEntity("Sound_GeneralLampOff_3", "custom/generator/light_off", "GeneralLamp_3", 0.4f, false, 1.0f);
        Sound_CreateAtEntity("Sound_GeneralLampOff_4", "custom/generator/light_off", "GeneralLamp_4", 0.4f, false, 1.0f);
        Sound_CreateAtEntity("Sound_GeneralLampOff_5", "custom/generator/light_off", "GeneralLamp_5", 0.4f, false, 1.0f);
        Sound_CreateAtEntity("Sound_GeneralLampOff_6", "custom/generator/light_off", "GeneralLamp_6", 0.4f, false, 1.0f);
        Sound_CreateAtEntity("gen_LightOff", "custom/generator/light_switch", "GeneratorRoom_SoundSpawner_2", 0.0f, false, 1.0f);
        
        Lamp_SetLit("generator_light", false, true);
        Lamp_SetLit("GeneralLamp_*", false, true);
        Lever_SetStuckState("Generator_Lever", -1, true);
        Map_AddTimer("Timer_AllowLeverUse", 1.0f, "Timer_AllowLeverUse");
        
        if (!mbKeyRoomInteracted) {
            SwingDoor_SetLocked("KeyRoom_Wall1_1", true, true);
            Prop_MoveLinearTo("KeyDoor_Blocker_1","KeyDoor_Blocker_3",70,70,0.2f,true);
            Entity_SetActive("KeyBlock", true);
        }
    }
    
    void Timer_AllowLeverUse(const tString &in asTimer)
    {
        Lever_SetStuckState("Generator_Lever", 0, false);
        Entity_SetInteractionDisabled("Generator_Lever", false);
        mbGenLeverOn = false;
    }
    
    bool mbKeyRoomInteracted = false;
    void KeyRoomInteract(const tString &in asEntity)
    {
        if (!SwingDoor_GetLocked(asEntity))
            mbKeyRoomInteracted = true;
    }
    
    //-------------------------------------------------------
    //EXIT SEQUENCE
    //-------------------------------------------------------

    void ExitDoor_OnInteract(const tString &in asEntity)
    {
        if (ItemType_GetFirstInInventory("ArsenalKey")!="") {
            Entity_SetActive("ExitBlock", false);
            SwingDoor_SetLocked("Exit_Wall1_1", false, true);

            Item_RemoveFromInventory(ItemType_GetFirstInInventory("ArsenalKey"));
            Entity_SetActive("ArsenalKey_Attached", true);
            Prop_AlignRotation("ArsenalKey_Attached", "ArsenalKey_AttachedRotated", 10.f, 5.f, 0.25f, true);

            Sound_CreateAtEntity("Sound_DoorUnlock", "level_entity_shared/doors/relic_door/relic_door_unlock", asEntity);
            
            iLuxEntity@ pDoor = cLux_GetCurrentMap().GetEntityByName("Exit_Wall1_1", eLuxEntityType_LastEnum, "");
            if (!(pDoor is null))
            {
                pDoor.GetBody(0).SetMass(10);
                pDoor.GetBody(1).SetMass(0);
            } else Error("Could not find the target entity "+"Exit_Wall1_1");
        }
    }
    
    // When you click on the exit ladder
    void OnExitLadder(const tString &in asEntity)
    {
        cLux_AddDebugMessage("Clicked on Exit Ladder");
    }

	//-------------------------------------------------------

	////////////////////////////
	// Run when leaving map
	void OnLeave()
	{
	}

	//-------------------------------------------------------

	////////////////////////////
	// The player has died.
	void OnPlayerKilled(int alRecentDeaths, const tString&in asSource)
	{
	}
	
	//-------------------------------------------------------
	
	////////////////////////////////////
	// Called when player HP reaches 0
	bool OnDeath(const tString &in asSource)
	{
		cLux_AddTodoMessage("DEAD : SOURCE = " + asSource);
		
		if (asSource == "SomeReason")
		{
			Effect_Fade_Out(1.0f);
			return true; // return true to completely override base behaviour
		}
		
		// return false for default behaviour
		return false;
	}
	
	//-------------------------------------------------------
	
	////////////////////////////////////
	// Called when player should respawn (after death)
	bool OnRespawn(const tString &in asSource)
	{		
		// return false for default behaviour (fadeout and death area)
		return false;
	}

	//-------------------------------------------------------

	////////////////////////////
	// To get when player makes input (mostly used for debug)
	void OnAction(int alAction, bool abPressed) 
	{
		if(abPressed==false) return;
		
		if(alAction == eAction_Test1)
		{
            iLuxEntity@ pMonster = Map_GetEntity("ghoul_1", eLuxEntityType_Agent);
            iLuxEntity@ pArea = Map_GetEntity("MonsterArea_"+1, eLuxEntityType_Area);
            if ((pMonster is null) || (pArea is null)) {
                Error("Could not find the target entity ghoul_1 or MonsterArea_"+1);
            } else {
                pMonster.SetPosition(pArea.GetPosition());
                Entity_SetActive("ghoul_1", true);
                Monster_PickSpot(false);
                bMonsterIsOut = true;
            }
		}
		if(alAction == eAction_Test2)
		{
            //Ghoul_CommandGoToSpecificHole_Execute("ghoul_1", "MonsterArea_"+lMonsterIndex, false, false, true);
            Entity_SetActive("asdasdsa_3", false);
		}
	}

	//-------------------------------------------------------

	////////////////////////////
	// This only used for pure debug purposes when info needs to printed.
	float DrawDebugOutput(cGuiSet @apSet,iFontData @apFont,float afY)
	{
		//afY = cLux_DrawDebugText("My Debug value:"+..., afY);
		return afY;
	}
 
	//-------------------------------------------------------
 
	//} END MAIN CALLBACKS
 
 
	//////////////////////////////////////////////////////////////////////////////////////////
	// ==============
	// MAIN FUNCTIONS
	// ==============
	//{///////////////////////////////////////////////////////////////////////////////////////
 
	//-------------------------------------------------------
	//-------------------------------------------------------
 
	//} END MAIN FUNCTIONS
 
}