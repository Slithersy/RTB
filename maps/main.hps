#include "interfaces/Map_Interface.hps"
#include "base/Inputhandler_Types.hps"

#include "helpers/helper_map.hps"
#include "helpers/helper_props.hps"
#include "helpers/helper_effects.hps"
#include "helpers/helper_audio.hps"
#include "helpers/helper_imgui.hps"
#include "helpers/helper_sequences.hps"
#include "helpers/helper_game.hps"
#include "helpers/helper_modules.hps"
#include "helpers/helper_ai.hps"
#include "helpers/helper_player.hps"
#include "helpers/helper_procedural.hps"
#include "helpers/helper_rotation.hps"

//--------------------------------------------------
 
/*Place any global values here. These must be const variables as they will not be saved*/
/*This is also the place for enums and classes, but these should be avoided whenever possible*/
 
//--------------------------------------------------
 
class cScrMap : iScrMap
{
	//--------------------------------------------
 
	//////////////////////////////////////////////////////////////////////////////////////////
	// ==============
	// MAIN CALLBACKS
	// ==============
	//{///////////////////////////////////////////////////////////////////////////////////////
 
	//-------------------------------------------------------
 
	////////////////////////////
	// Set up map environment
	void Setup()
	{
		// Put display name entry in english.lang / Levels
		GetBase().SetDisplayNameEntry("main-bunker-level");
        
        // Basic can can't do
        Player_SetAllowCheckBaby(false);
		
		// Set up color grading etc.
	}
	
	//-------------------------------------------------------
		
	void PreloadData()
	{
		/////////////////
		// Preload gui
		//ImGui_PreloadImage("some_image");

		///////////////
		// Preload particles
		//ParticleSystem_Preload("some_particle.ps");

		//////////////
		// Preload screen effects
		//Material_Preload("some_material.mat");
	}
	
	//-------------------------------------------------------

	////////////////////////////
	// Run first time starting map
    
    // Enterance
    tString msFirstRemovedWall = "";
    
    array<int> mvStack;
	void OnStart()
	{
        // Give player stuff
        if (ItemType_GetCountInInventory("Lantern") < 1)
        {
            Item_AddToInventory("Lantern");
            Lantern_SetAmount(10);
            Item_Equip("Lantern");
        }
        
        Item_AddToInventory("ModernOil");
        Item_AddToInventory("ModernOil");
        Item_AddToInventory("ModernOil");
        Item_AddToInventory("ModernOil");
        // Remove bracelet and add watch instead
        Item_AddToInventory("Watch");
        Item_RemoveFromInventory(ItemType_GetFirstInInventory("CurseMedallion"));
            
		/////////////////////////
		// MAZE GENERATION
        
        //Reset everything to default
        Chunk_ResetArray();
        
        // Pick starting chunk
        int lChunkStart = cMath_RandRectl(1, 64);
        Chunk_SetStartingCell(lChunkStart);
        int lNeighbourCell = 1;
        cLux_AddDebugMessage("Start chunk - "+lChunkStart);
        Player_PlaceAtEntity("start_chunk_"+lChunkStart, true);
        // Mark as visited
        Chunk_SetBeenVisited(lChunkStart, true);
        
        // Pick a neighbouring cell that haven't been visited, currently all and set the walls between us and it inactive
        // Also set it visited
        lNeighbourCell = Chunk_PickNeighbouringCell(lChunkStart);
        if (lNeighbourCell!=-1)
            msFirstRemovedWall = Chunk_SetWallBetweenCells(lChunkStart, lNeighbourCell, false);
            mvStack.insertLast(lNeighbourCell);
            Chunk_SetBeenVisited(lNeighbourCell, true);
            
        // For realism, make a chunk where the door is supposed to be unuseable
        if ((lChunkStart+1) == lNeighbourCell) { //Right
            tString sWall = Chunk_SetWallBetweenCells(lChunkStart,lChunkStart-1, true);
            if (sWall != "") {
                int lChunk = cString_ToInt(cString_Split(sWall, "_")[2], lChunkStart);
                Chunk_SetBeenVisited(lChunk, true);
                Chunk_SetContainsBuilding(lChunk, true);
            }
        } else if ((lChunkStart-1) == lNeighbourCell) { //Left
            tString sWall  = Chunk_SetWallBetweenCells(lChunkStart, lChunkStart+1, true);
            if (sWall != "") {
                array<tString> vWallSplit = cString_Split(sWall, "_");
                if (vWallSplit.size()>3) {
                    int lChunk = cString_ToInt(vWallSplit[3], lChunkStart);
                    Chunk_SetBeenVisited(lChunk, true);
                    Chunk_SetContainsBuilding(lChunk, true);
                }
            }
        } else if ((lChunkStart+8) == lNeighbourCell) { //Up
            tString sWall  = Chunk_SetWallBetweenCells(lChunkStart, lChunkStart-8, true);
            if (sWall != "") {
                int lChunk = cString_ToInt(cString_Split(sWall, "_")[2], lChunkStart);
                Chunk_SetBeenVisited(lChunk, true);
                Chunk_SetContainsBuilding(lChunk, true);
            }
        } else if ((lChunkStart-8) == lNeighbourCell) { //Down
            tString sWall  = Chunk_SetWallBetweenCells(lChunkStart, lChunkStart+8, true);
            if (sWall != "") {
                array<tString> vWallSplit = cString_Split(sWall, "_");
                if (vWallSplit.size()>3) {
                    int lChunk = cString_ToInt(vWallSplit[3], lChunkStart);
                    Chunk_SetBeenVisited(lChunk, true);
                    Chunk_SetContainsBuilding(lChunk, true);
                }
            }
        }
            
        int lSafetyCheck = 0;
        bool bNonVisistedExist = true;
        while (bNonVisistedExist) {
            // If there are unvisited chunks keep looping, otherwise stop
            bool bShouldStopLoop = true;
            for (int i=1;i<65;i++) {
                if (!Chunk_HasBeenVisited(i)) {
                    bShouldStopLoop = false;
                    break;
                }
            }
            if (bShouldStopLoop)
                bNonVisistedExist = false;
            
            // from 0.0f - 0.99f how likely is the for loop to skip for more randomization
            float fSkipChance = 0.65f;
            // from 0.1f - 0.99f how random do you want the array to be
            float fRandomizeChance = 0.99f;
            array<int> vRandomizedStack = RandomizeArray(mvStack, fRandomizeChance);
            int length = vRandomizedStack.length();
            
            // Here the magic happens! (I'm so happy this works) :>
            for (int i=0;i<length;i++) {
                if (fSkipChance < cMath_RandRectf(0.0f,1.0f)) {
                    cLux_AddDebugMessage("Picking neighbour around: "+vRandomizedStack[i]);
                    int lNewNeighbourCell = Chunk_PickNeighbouringCell(vRandomizedStack[i]);
                    cLux_AddDebugMessage("Picked: "+lNewNeighbourCell);
                    if (lNewNeighbourCell!=-1) {
                        Chunk_SetWallBetweenCells(vRandomizedStack[i], lNewNeighbourCell, false);
                        mvStack.insertLast(lNewNeighbourCell);
                        Chunk_SetBeenVisited(lNewNeighbourCell, true);
                    }
                }
            }
            
            if (lSafetyCheck>70) {
                bNonVisistedExist = false;
                Error("While infinite loop in main!!!");
            }
            
            lSafetyCheck++;
        }
        
        ///////////////////
        // ENTERANCE
        
        // First remove roof
        Entity_SetActive("roof_chunk_"+lChunkStart, false);  
        Chunk_SetContainsBuilding(lChunkStart, true);
        
        // Place Enterance
        iLuxEntity@ pPlayerStart = Map_GetEntity("start_chunk_"+lChunkStart, eLuxEntityType_Area);
        if (pPlayerStart is null)
        {
            Error("Could not find the target entity "+"start_chunk_"+lChunkStart);
            return;
        }
        
        iLuxEntity@ pEnterance = Map_GetEntity("Enterance", eLuxEntityType_Area);
        if (pEnterance is null)
        {
            Error("Could not find the target entity Enterance");
            return;
        }
        pEnterance.SetPosition(pPlayerStart.GetPosition());
        
        // Set rotation
        Entity_FaceToEntity("Enterance", msFirstRemovedWall, false);
        
        
        ///////////////////
        // EXIT/BUILDING GENERATION
        Building_PlaceInChunk("Exit", -1, 1.0f);
        Building_PlaceInChunk("GeneratorRoom", -1);
        Building_PlaceInChunk("KeyRoom", -1, 1.0f, 0.0f);
        Building_PlaceInChunk("MedRoom", -1);
        Building_PlaceInChunk("ArmoryRoom", -1);
        
        // Generate Assets
        for (int i=1;i<=5;i++) {
            Building_PlaceInChunk("LampArea_"+i, -1, 0.2f, 0.8f);
        }
	}

	//-------------------------------------------------------

	////////////////////////////
	// Run when entering map
	void OnEnter()
	{
		/////////////////////////
		// Debug
		if(cLux_ScriptDebugOn())
		{
		}
        
        // Basic player stuff
        PlayerBody_SetActive(true);
        FearHandler_SetActive(true);
        FearHandler_SetPaused(false);
        FearHandler_SetAllowLanternReminderHint(true);
        FearHandler_SetDarknessFactorActive(true);
		FearHandler_SetUpdateInterval(0.1f);
        FearHandler_SetMaxLevel(2.0f);
        Player_SetMapDeepShadow(0.9f);
		FearHandler_SetPermaFailEnabled(true);
        Heat_SetActive(false);
		Player_SetNightVisionBrightness(2.3f);
		Player_SetNightVisionRadius(5.5f);
        
		Game_AutoSave();
	}
    
    //-------------------------------------------------------
    //GENERATOR SEQUENCE
    //-------------------------------------------------------
    
    float mfChanceOfFailure = 0.2f;
    bool mbGenLeverOn = false;
    void GeneratorLevelInteract(const tString &in asEntity)
    {
        if ((Lever_GetState(asEntity) == 1) && (!mbGenLeverOn)) {
            Seq_GeneratorStart("");
            mbGenLeverOn = true;
            Entity_SetInteractionDisabled("Generator_Lever", true);
        }
    }
    
    bool bPlayedVoice = false;
    void PlayTryAgainHint()
    {
        if (!bPlayedVoice) {
            Voice_Play("Dialogue_TryGen");
            bPlayedVoice = true;
        }
    }
    
	cSequenceStatesData mSequenceGeneratorStart;
	void Seq_GeneratorStart(const tString &in asTimer)
	{
		Sequence_Begin("Seq_GeneratorStart", mSequenceGeneratorStart);
		if (Sequence_DoStepAndWait(1.0f))
		{
            ParticleSystem_CreateAtEntity("gen_spark1", "elec_spark_medium_oneshot.ps", "GeneratorRoom_ParticleSpawner_1", true);
            Sound_CreateAtEntity("gen_spark1_noise", "custom/generator/spark", "GeneratorRoom_ParticleSpawner_1", 0.0f, false, 1.0f);
            
            int lRanInt = cMath_RandRectl(0, 100);
            float fRanFloat = lRanInt/100.0f;
            cLux_AddDebugMessage(""+fRanFloat+" is lower than "+mfChanceOfFailure);
            if (fRanFloat < mfChanceOfFailure) {
                Lever_SetStuckState("Generator_Lever", -1, true);
                Map_AddTimer("Timer_AllowLeverUse", 1.0f, "Timer_AllowLeverUse");
                PlayTryAgainHint();
                Sequence_Stop();
            }
		}
		else if (Sequence_DoStepAndWait(0.7f))
		{
            ParticleSystem_CreateAtEntity("gen_spark2", "elec_spark_medium_oneshot.ps", "GeneratorRoom_ParticleSpawner_2", true);
            Sound_CreateAtEntity("gen_spark2_noise", "custom/generator/spark", "GeneratorRoom_ParticleSpawner_2", 0.0f, false, 1.0f);
            
            int lRanInt = cMath_RandRectl(0, 100);
            float fRanFloat = lRanInt/100.0f;
            if (fRanFloat < mfChanceOfFailure) {
                Lever_SetStuckState("Generator_Lever", -1, true);
                Map_AddTimer("Timer_AllowLeverUse", 1.0f, "Timer_AllowLeverUse");
                PlayTryAgainHint();
                Sequence_Stop();
            }
        }
		else if (Sequence_DoStepAndWait(0.7f))
		{
            ParticleSystem_CreateAtEntity("gen_spark3", "elec_spark_medium_oneshot.ps", "GeneratorRoom_ParticleSpawner_3", true);
            Sound_CreateAtEntity("gen_spark3_noise", "custom/generator/spark", "GeneratorRoom_ParticleSpawner_3", 0.0f, false, 1.0f);
        }
		else if (Sequence_DoStepAndWait(2.f))
		{
            Lamp_SetLit("generator_light", true, true);
            Lamp_SetLit("GeneralLamp_1", true, true);
            Sound_CreateAtEntity("Sound_GeneralLamp_1", "custom/generator/light_buzz", "GeneralLamp_1", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("GeneratorStart", "custom/generator/generator_on", "GeneratorRoom_SoundSpawner", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("gen_LightOn1", "custom/generator/light_on", "GeneratorRoom_SoundSpawner_2", 0.0f, false, 1.0f);
        }
		else if (Sequence_DoStepAndWait(3.f))
		{
            Lamp_SetLit("GeneralLamp_*", true, true);
            Sound_CreateAtEntity("Sound_GeneralLamp_2", "custom/generator/light_buzz", "GeneralLamp_2", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("Sound_GeneralLamp_3", "custom/generator/light_buzz", "GeneralLamp_3", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("Sound_GeneralLamp_4", "custom/generator/light_buzz", "GeneralLamp_4", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("Sound_GeneralLamp_5", "custom/generator/light_buzz", "GeneralLamp_5", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("Sound_GeneralLamp_6", "custom/generator/light_buzz", "GeneralLamp_6", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("Sound_GeneralLamp_7", "custom/generator/light_buzz", "GeneralLamp_7", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("Sound_GeneralLamp_8", "custom/generator/light_buzz", "GeneralLamp_8", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("Sound_GeneralLamp_9", "custom/generator/light_buzz", "GeneralLamp_9", 1.2f, true, 1.0f);
            Sound_CreateAtEntity("gen_LightOn2", "custom/generator/light_switch", "GeneratorRoom_SoundSpawner_2", 0.0f, false, 1.0f);
            Map_AddTimer("Timer_GeneratorStop", 30.0f, "Timer_GeneratorStop");
            
            if (!mbKeyRoomInteracted)
                Prop_MoveLinearTo("KeyDoor_Blocker_1","KeyDoor_Blocker_2",70,70,0.2f,true);
        }
		else if (Sequence_DoStepAndWait(2.f))
		{
            if (!mbKeyRoomInteracted) {
                SwingDoor_SetLocked("KeyRoom_Wall1_1", false, true);
                Entity_SetActive("KeyBlock", false);
            }
        }
		Sequence_End();
	}
    
    void Timer_GeneratorStop(const tString &in asTimer)
    {
        Sound_Stop("GeneratorStart", 0.5f);
        Sound_Stop("Sound_GeneralLamp_*", 0.5f);
        Sound_CreateAtEntity("Sound_GeneralLampOff_1", "custom/generator/light_off", "GeneralLamp_1", 0.4f, false, 1.0f);
        Sound_CreateAtEntity("Sound_GeneralLampOff_2", "custom/generator/light_off", "GeneralLamp_2", 0.4f, false, 1.0f);
        Sound_CreateAtEntity("Sound_GeneralLampOff_3", "custom/generator/light_off", "GeneralLamp_3", 0.4f, false, 1.0f);
        Sound_CreateAtEntity("Sound_GeneralLampOff_4", "custom/generator/light_off", "GeneralLamp_4", 0.4f, false, 1.0f);
        Sound_CreateAtEntity("Sound_GeneralLampOff_5", "custom/generator/light_off", "GeneralLamp_5", 0.4f, false, 1.0f);
        Sound_CreateAtEntity("Sound_GeneralLampOff_6", "custom/generator/light_off", "GeneralLamp_6", 0.4f, false, 1.0f);
        Sound_CreateAtEntity("gen_LightOff", "custom/generator/light_switch", "GeneratorRoom_SoundSpawner_2", 0.0f, false, 1.0f);
        
        Lamp_SetLit("generator_light", false, true);
        Lamp_SetLit("GeneralLamp_*", false, true);
        Lever_SetStuckState("Generator_Lever", -1, true);
        Map_AddTimer("Timer_AllowLeverUse", 1.0f, "Timer_AllowLeverUse");
        
        if (!mbKeyRoomInteracted) {
            SwingDoor_SetLocked("KeyRoom_Wall1_1", true, true);
            Prop_MoveLinearTo("KeyDoor_Blocker_1","KeyDoor_Blocker_3",70,70,0.2f,true);
            Entity_SetActive("KeyBlock", true);
        }
    }
    
    void Timer_AllowLeverUse(const tString &in asTimer)
    {
        Lever_SetStuckState("Generator_Lever", 0, false);
        Entity_SetInteractionDisabled("Generator_Lever", false);
        mbGenLeverOn = false;
    }
    
    bool mbKeyRoomInteracted = false;
    void KeyRoomInteract(const tString &in asEntity)
    {
        if (!SwingDoor_GetLocked(asEntity))
            mbKeyRoomInteracted = true;
    }
    
    //-------------------------------------------------------
    //EXIT SEQUENCE
    //-------------------------------------------------------

    void ExitDoor_OnInteract(const tString &in asEntity)
    {
        if (ItemType_GetFirstInInventory("ArsenalKey")!="") {
            Entity_SetActive("ExitBlock", false);
            SwingDoor_SetLocked("Exit_Wall1_1", false, true);

            Item_RemoveFromInventory(ItemType_GetFirstInInventory("ArsenalKey"));
            Entity_SetActive("ArsenalKey_Attached", true);
            Prop_AlignRotation("ArsenalKey_Attached", "ArsenalKey_AttachedRotated", 10.f, 5.f, 0.25f, true);

            Sound_CreateAtEntity("Sound_DoorUnlock", "level_entity_shared/doors/relic_door/relic_door_unlock", asEntity);
            
            iLuxEntity@ pDoor = cLux_GetCurrentMap().GetEntityByName("Exit_Wall1_1", eLuxEntityType_LastEnum, "");
            if (!(pDoor is null))
            {
                pDoor.GetBody(0).SetMass(10);
                pDoor.GetBody(1).SetMass(0);
            } else Error("Could not find the target entity "+"Exit_Wall1_1");
        }
    }
    
    // When you click on the exit ladder
    void OnExitLadder(const tString &in asEntity)
    {
        cLux_AddDebugMessage("Clicked on Exit Ladder");
    }

	//-------------------------------------------------------

	////////////////////////////
	// Run when leaving map
	void OnLeave()
	{
	}

	//-------------------------------------------------------

	////////////////////////////
	// The player has died.
	void OnPlayerKilled(int alRecentDeaths, const tString&in asSource)
	{
	}
	
	//-------------------------------------------------------
	
	////////////////////////////////////
	// Called when player HP reaches 0
	bool OnDeath(const tString &in asSource)
	{
		cLux_AddTodoMessage("DEAD : SOURCE = " + asSource);
		
		if (asSource == "SomeReason")
		{
			Effect_Fade_Out(1.0f);
			return true; // return true to completely override base behaviour
		}
		
		// return false for default behaviour
		return false;
	}
	
	//-------------------------------------------------------
	
	////////////////////////////////////
	// Called when player should respawn (after death)
	bool OnRespawn(const tString &in asSource)
	{		
		// return false for default behaviour (fadeout and death area)
		return false;
	}

	//-------------------------------------------------------

	////////////////////////////
	// To get when player makes input (mostly used for debug)
	void OnAction(int alAction, bool abPressed) 
	{
		if(abPressed==false) return;
		
		if(alAction == eAction_Test1)
		{
            int Chunk = 28;
            int lBlockNum = 1;
            array<int> BlockedChunks;
            // Find all unavailable chunks
            int lLeft = 0;
            int lRight = 0;
            int lUp = 0;
            int lDown = 0;
            for (int i=1;i<=lBlockNum;i++) {
                //Check left
                if (Chunk_GetLevel(Chunk-i) == Chunk_GetLevel(Chunk))
                    lLeft++;
                //Check right
                if (Chunk_GetLevel(Chunk+i) == Chunk_GetLevel(Chunk))
                    lRight++;
                //Check up
                if ((Chunk+(8*i)) <= 64)
                    lUp++;
                //Check down
                if ((Chunk-(8*i)) >= 1)
                    lDown++;
            }
            
            for (int i=(Chunk-lLeft);i<=(Chunk+lRight);i++) {
                BlockedChunks.insertLast(i); //Insert current line into blocked
                if (lUp>0) { //Insert all top lines
                    for (int k=1;k<=lUp;k++) {
                        BlockedChunks.insertLast(i+(8*k));
                    }
                }
                if (lDown>0) { //Insert all bottom lines
                    for (int k=1;k<=lDown;k++) {
                        BlockedChunks.insertLast(i-(8*k));
                    }
                }
            }
            
            cLux_AddDebugMessage("lLeft: "+ lLeft);
            cLux_AddDebugMessage("lRight: "+ lRight);
            cLux_AddDebugMessage("lUp: "+ lUp);
            cLux_AddDebugMessage("lDown: "+ lDown);
            
            for (int Chunk=1;Chunk<65;Chunk++) {
                if (BlockedChunks.find(Chunk) >= 0)
                    cLux_AddDebugMessage("Blocked chunk: "+ Chunk);
            }
		}
	}

	//-------------------------------------------------------

	////////////////////////////
	// This only used for pure debug purposes when info needs to printed.
	float DrawDebugOutput(cGuiSet @apSet,iFontData @apFont,float afY)
	{
		//afY = cLux_DrawDebugText("My Debug value:"+..., afY);
		return afY;
	}
 
	//-------------------------------------------------------
 
	//} END MAIN CALLBACKS
 
 
	//////////////////////////////////////////////////////////////////////////////////////////
	// ==============
	// MAIN FUNCTIONS
	// ==============
	//{///////////////////////////////////////////////////////////////////////////////////////
 
	//-------------------------------------------------------
	//-------------------------------------------------------
 
	//} END MAIN FUNCTIONS
 
}